% This example An LaTeX document showing how to use the l3proj class to
% write your report. Use pdflatex and bibtex to process the file, creating 
% a PDF file as output (there is no need to use dvips when using pdflatex).

% Modified 

\documentclass{l3proj}

\begin{document}

\title{ESE1 Team Project Dissertation}

\author{Agnes Ola \\
        Ross James Gardiner \\
        Lorenzo Roccato \\
        Duncan Lowther \\
        Nawaf Al Lawati}

\date{6 April 2020}

\maketitle

\begin{abstract}

%% The abstract goes here

\end{abstract}

%% Comment out this line if you do not wish to give consent for your
%% work to be distributed in electronic format.
\educationalconsent

\newpage

\section{Marking sheme - remove before submission}

Reflecting on your practice is the hardest part of writing the dissertation, so you are encouraged to talk to the course coordinators and demonstrators to find out what you could include in this section. A good source of examples of incidents for reflection is often the documentation from your retrospectives, because you used the retrospectives to identify areas of your process that could be changed or done better. You should also, try to relate your experiences to other studies available in the software engineering literature (the recommended reading is a good starting point for this).

For example, if you found that you had to drop a feature during an iteration, discuss the reasons why the feature had to be dropped. Had you given yourselves too much work? Was the feature harder to implement than you realised? Had you got your priorities wrong? Then consider looking at the literature (see the recommended reading for PSD3) on project planning and estimation. Was your experience typical of a software project? What steps do other developers advocate for improving estimation?

Alternatively, did you have to make some big design decisions or choice of software platforms early on in the project? What impact did these choices have? Were they the right ones? How might you have improved the decision making process to reduce uncertainty? Did you implement a prototype before proceeding to far with the main implementation? How much effort did this involve? What did you learn about the platform as a result?

The dissertation should be a single PDF document of a maximum of 12 pages, not including front matter and references. You must use the LaTeX template provided for the dissertation and include all the requested meta-data. The LaTeX source for the template, your dissertation and any associated figures should be stored in your version control repository in a clearly indicated directory or branch. It must be possible to build the dissertation PDF from this source, using an automated build script, such as the ant build script provided.

\begin{itemize}
\item Presentation/structure -  	Is the dissertation complete, well organised, clear and literate? Are there examples of spelling mistakes or poor grammar in the dissertation? Is there a clear logical argument and structure to the narrative? Are references used effectively? Are the references complete?
\item Description of objectives and achievements. - Are the problem domain, scope and objectives of the project clear? Is it clear what was achieved during the project and what the key technical challenges were?
\item Reflection -  	Are there a number of experiences/critical events discussed in the dissertation? Does each experience answer the following questions: What was the circumstances of the event? What was learned as a result of the experience? What changed in the project team (if anything) as a result of the experience? Is the experience related to other case studies available in the software engineering literature?
\end{itemize}

%==============================================================================
\section{Introduction}



Software engineering 

This paper presents a case study of... 
%% An introduction, explaining the purpose of the document, a very brief outline of the project and a summary of the structure of the rest of the document (approximately 1 pages).

%% Final paragraph.
The rest of the case study is structured as follows.  Section
\ref{sec:background} presents the background of the case study
discussed, describing the customer and project context, aims and
objectives and project state at the time of writing.  Sections
\ref{sec:Issue1} through Section \ref{sec:Issue3} discuss issues that
arose during the project...

%==============================================================================
\section{Case Study Background}

Include details of 
%% A description of the case study background and context. This should include a description of the project customer (what was the nature of the organisation you were working for), their objectives for the project, and a summary of what was actually achieved. Where appropriate, this section should also make reference to similar related projects in order to make the context clear (approximately 1-3 pages).

\subsection{Our client}
%% The customer organisation and background.
\subsection{Our project}
%%  The rationale and initial objectives for the project.
\subsection{Our software}
%% The final software was delivered for the customer.
%% Did what viable prouct said it would do
%% Improvements: multi test display, less clutter, fewer unused features, uneditable calibration file, graph overlay, exp;licit functions, no error messages
%% Research made into wireless solution
%==============================================================================
\section{Reflections}
\subsection{Propagation of early design decisions}

Development of the graphical user interface (GUI) for the application introduced a significant amount of technical debt to the project. Technical debt describes scenarios in software development practice where developers take shortcuts or implement workarounds\cite{yli-huumo} to make quick progress and push an earlier release\cite{kruchten} or accept sacrifices in software quality in order to meet a deadline\cite{zazworka}. Johann describes how every development team must decide if their technical debt should be "paid" (replaced the software component), "converted" (modified in place) or "accepted" (accepted that the cost of replacing the software is more than the cost of maintaining it)\cite{wolff}.\\
The team had no experience in writing GUI applications aside from an introductory Python course two years ago, so time was allocated to research possible solutions, choose the most appropriate tools and learn how to use them effectively. Unfortunately, not having any sort of reference user interface hindered the early progress of other tasks, particularly connecting backend (driver software) to frontend and implementing display of accelerator data. A temporary mockup of the legacy program was created so behaviour (such as action listeners) could be attached to GUI objects and make it easier for other members of the team to make contributions before the GUI was finalised.\\
The decision to implement a temporary solution had an overall negative effect on the software. It reduced the sense of urgency about this aspect of the program and it felt unnecessary to return to it considering many other unimplemented features in the issue log. It also caused us to develop a sort of blindness to its flaws - whenver a GUI bug was discovered, it was brushed off citing the pending reskin of the application. In the future we will create more detailed issues describing specific bugs so make sure all the issues are properly addressed in the final version.\\
We used Windowbuilder Eclipse plugin to create a Java Swing based interface. Windowbuilder saves time, explains features and simplifies configuration of various Swing components\cite{windowbuilder}. While WIndowbuilder was undeniably a great asset to the project, it also caused some issues. Occasionally when moving components in Windowbuilder, the corresponding code would seemingly randomly moved to a different part of the file, in some cases ending up in the middle of another logical code block (and even inside method calls) and in all cases failed to move comments assiciated with the code to the new location. Not only reverting the changeswasted the developer's time, a few times the damage to program logic wasn't apparent until several commits later, in one case causing the developer to abandon the entire branch as it took less time to reimplement the changes than untangle the code. Rearrangement of layout components also caused numerous merge conflicts in places where code had not actually been modified, further slowing development.\\
Another problem caused by "temporary" code was the unreadable variable naming. As the entire interface was recreated from scratch several times early in the learning process, the version that ended up being used for majority of the project was filled with default Windowbuilder allocated variable names, that could only be deciphered by lauching the GUI. This was immediately recognised as a problem, but the properly named variables caused merge conflicts on nearly every line of the program, once again forcing the team to abandon changes. In the end it was only possible to rename variables and revamp the layout of the application only when all other tasks had been completed, only a few hours before code freeze.\\
Temporary code is useful and unavoidable \cite{halpern} and indeed imporved divisibility of the workload. In hindsight it is also common to attribute lack of flexibilty or errors in code to taking shortcuts\cite{stopford}. Considering that our ability to use GUI tools was considerably further along the learning curve, the early decisions unfairly feel poorly planned. \\
There are a number of things we will do differenly next time. It would have been immensely useful to create a high level description of the components and their names, such as a sketch. We have learned that implementing a temporary solution and then stubbornly sticking to it due to the perceived difficulty of adddressing the technical debt can (and in this case did) cost os more time and effort than it saved. It would have also helped to create earlier released of the software to force everyone to acknowledge the cracks in the seams.\\
Considering the lack of experience with similar tasks, it would have been prudent to seek advice from faculty or classmates about the feasability of our plans and suitabilty of the tools we chose to benefit for the skill boost associated with working with experienced colleagues\cite{panwong}. It would have also helped to prioritise tasks that did not rely on GUI interaction (such as research, documentation and project planning) to allow more time for the development of a good quality graphical interface. Finally, in future projects we should take great care to decouple layout elements from logic (methods) to increase readability and reduce the time cost of editing the layout file.

%==============================================================================
\subsection{Testing or lack thereof}

Incidents and events
- Set up yaml / autotesting - it mostly failed due to forgetting to add supporitng files to repo. Medium useful, but mostly a dry run learning exercise
- Old software was kind of shit at working without the hardware and it was hard to see if the results were the same
- Very hard to make progress away from St Alwin building because you don't know if you're going in the right direction - therefore progress somewhat sporadic
- Even when things do work it's difficult to prove (like with the testing exercise)

What we learned:
- A hardware emulator would have helped, but would the effort of building one be worth it?
- Agree on more rigorous manual tests?
- Agree each person goes in each weekday and tests everyone's progress? Would have helped with familiarity of each other's code too.

%==============================================================================
\subsection{Issue3}

%% Several sections that reflect on your experiences during the team project. Each section should discuss one theme, characterised by incidents or events that occurred during the team course of the project from which you learned (approximately 8-10 pages).
%==============================================================================

\section{Conclusions}
%% A conclusion that draws general and wider lessons from the case study (approximately 1-2 pages).
Explain the wider lessons that you learned about software engineering,
based on the specific issues discussed in previous sections.  Reflect
on the extent to which these lessons could be generalised to other
types of software project.  Relate the wider lessons to others
reported in case studies in the software engineering literature.

- Important learning experience
- Large emphasis on writing code itself, not enough 

%==============================================================================
\bibliographystyle{plain}
\bibliography{dissertation}
\end{document}
